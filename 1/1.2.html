<!doctype html>
<html>
  
  <head>
    <title>
      CppPrimer
    </title>
    <link rel="icon" href="../favicon.ico">
    <meta charset="utf-8">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet"
      href="//unpkg.com/@highlightjs/cdn-assets@11.2.0/styles/github-dark.min.css">
<script src="//unpkg.com/@highlightjs/cdn-assets@11.2.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  
  <body>
    <center>
    <a href="../index.html"><h3>C++ 기초</h3></a>      
    <hr width="50%" noshade>
    </center>
    
    <div class="row">
      <div class="left">
        <ol>
          <li><mark id="red">시작</mark></li>
        <li><a href="../1/0.html">기본</a></li>
        <li><a href="../3/0.html">문자열, 벡터, 배열</a></li>
        <li><a href="../4/0.html">표현식</a></li>
        <li><a href="../5/0.html">문장</a></li>
        <li><a href="../6/0.html">함수</a></li>
        <li><a href="../7/0.html">클래스</a></li>
        <li><a href="../8/0.html">IO 라이브러리</a></li>
        <li><a href="../9/0.html">순차 컨테이너</a></li>
        <li><a href="../10/0.html">제네릭 알고리즘</a></li>
        <li><a href="../11/0.html">연관 컨테이너</a></li>
        <li><a href="../12/0.html">동적 메모리</a></li>
        <li><a href="../13/0.html">복사 제어</a></li>
        <li><a href="../14/0.html">연산자 오버로드 및 변환</a></li>
        <li><a href="../15/0.html">객체 지향 프로그래밍</a></li>
        <li><a href="../16/0.html">템플릿과 제네릭 프로그래밍</a></li>
        <li><a href="../17/0.html">라이브러리 특수 기능</a></li>
        <li><a href="../18/0.html">대형 프로그램 도구</a></li>
        <li><a href="../19/0.html">특수 도구 및 기법</a></li>
      </ol> 
      <ul>
        <li>부록 <a href="../A/html">라이브러리</a></li>
      </ul>
      </div>
      
      <div class="center">
        <ol>
          <li><a href="1.1.html">간단한 C++ 프로그램 작성</a></li>
          <li><mark id="red">입력/출력 소개</mark></li>
          <li><a href="1.3.html">주석에 관해</a></li>
          <li><a href="1.4.html">제어의 흐름</a></li>
          <li><a href="1.5.html">클래스 소개</a></li>
          <li><a href="1.6.html">서점 프로그램</a></li>
        </ol>
        <ul>
          <li><a href="1.a.html">단원 요약</a></li>
          <li><a href="1.b.html">용어 정리</a></li>
        </ul>
      </div>
      
      <div class="right">
        <ol>
        </ol>
      </div>
    </div>
    
    <hr width="100%" noshade>
    
<p>C++ 언어에는 입력 및 출력(IO) 수행이 정의된 문장이 없다. 
  대신 C++는 광범위한 <b>표준 라이브러리(standard library)</b>를 통해 IO를 (비롯한 여러 기능을) 제공한다.
  이 책의 예제를 포함한 다양한 상황에서는 IO 라이브러리에서 기본 개념 몇 가지만 알면 된다.</p>
    
    <p>이 책의 예제는 대부분 <mark>iostream</mark> 라이브러리를 사용한다.
      <mark>iostream</mark> 라이브러리에서 근본적인 것은 <mark>istream</mark>과 <mark>ostream</mark>이라는 이름의 두 가지 타입으로, 입력 및 출력 스트림(stream)이라는 뜻이라고 말할 수 있다.
      스트림이란 IO 장치에서 읽히거나 쓰인 일련의 문자(sequence of character)다.
      스트림(흐름)이라는 용어는 문자들이 시간의 흐름에 따라 순차적으로 생성되거나 소비되었다는 점을 암시하기 위한 것이다.</p>
    
    <p><h4>표준 입력 및 출력 객체</h4>
    라이브러리는 네 가지 IO 객체를 정의한다.
    입력을 위해 <mark>cin</mark>이라는 이름의 <mark>istream</mark> 타입 객체를 사용하는데, 이 객체는 <b>표준 입력(standard input)</b>이라고 지시되기도 한다. 
    출력을 다루기 위해서는 <mark>cout</mark>이라고 불리는 <mark>ostream</mark> 객체를 사용한다.
    이 객체 또한 <b>표준 출력(standard output)</b>이라고 알려져 있다.
    라이브러리는 두 가지 또 다른 <mark>ostream</mark> 객체를 정의하는데, <mark>cerr</mark>과 <mark>clog</mark>라고 불리는 (<b>씨-얼</b> 그리고 <b>씨-로그</b>라고 발음되는) 것들이다.
    <mark>cerr</mark>은 <b>표준 오류(standard error)</b>라는 것을 지시하기 위해 쓰이며, 경보와 오류 메시지를 위한 것이고, <mark>clog</mark>는 프로그램 실행에 관한 일반적인 정보를 위해 쓰이는 것이다.</p>
  
  <p>일반적으로 시스템은 프로그램이 실행되는 창(window)을 통해 이들 객체와 교류한다.
    따라서 <mark>cin</mark>을 통해 읽을 때, 자료는 프로그램이 실행되는 창을 통해 입력되고, <mark>cout</mark>, <mark>cerr</mark>, <mark>clog</mark>에 적을 때의 출력 또한 같은 장에서 작성된다.</p>
  
  <h4>IO 라이브러리를 사용하는 프로그램</h4>
  <p>우리의 서점 프로그램에는 단일의 총합으로 합칠 여러 가지 자료가 있다.
    더 단순한 관련 문제로, 어떻게 두 수를 합칠 수 있을지 살펴보자.
    IO 라이브러리를 통해, 사용자에게 두 수를 받은 다음 그 합을 출력하도록 <mark>main</mark> 프로그램을 확장할 수 있다.</p>
  <pre><code>#include &lt;iostream&gt;
int main()
{
    std::cout << "Enter two numbers:" << std::endl;
    int v1 = 0, v2 = 0;
    std::cin >> v1 >> v2;
    std::cout << "The sum of " << v1 << " and " << v2
              << " is " << v1 + v2 << std::endl;
    return 0;
}</code></pre>
<p>이 프로그램은 사용자의 스크린에 다음 문장을 출력하면서 시작한다.</p>
  <pre><code>Enter two numbers:</code></pre>
  <p>그런 다음 사용자에게서 입력을 기다린다. 
    만약 사용자가 아래처럼 입력한 다음 개행(newline)을 입력했다면</p>
  <pre><code>3 7</code></pre>
  <p>프로그램은 다음과 같은 출력을 생산한다.</p>
  <pre><code>The sum of 3 and 7 is 10</code></pre>
  <p>프로그램 첫 라인인 아래 라인은</p>
  <pre><code>#include &lt;iostream&gt;</code></pre>
  컴파일러에 우리가 <mark>iostream</mark> 라이브러리를 사용하고 싶다고 전달한다.
  꺾쇠 안의 이름은 (이 경우에는 <mark>iostream</mark>인데) <b>헤더(header)</b>를 가리킨다.
  라이브러리를 사용하는 모든 프로그램은 관련 헤더를 포함해야 한다.
  <mark>#include</mark>는 단일 라인에서 작성되어야 하는데, 이는 헤더 이름과 <mark>#include</mark>가 같은 문장에 나타나야 한다는 말이다.
  일반적으로, <mark>#include</mark>는 모든 함수 바깥에 나타나야 한다. 특징적으로는, 모든 <mark>#include</mark>를 소스 파일 시작 부분에 배치한다.

  <h4>스트림에 작성하기</h4>
  <mark>main</mark> 몸체의 첫 번째 문장은 <b>표현식(expression)</b>을 실행시킨다.
  C++에서 표현식은 하나의 결과를 가져오고 하나 이상의 피연산자와 (보통은) 하나의 연산자로 구성된다.
  이 문장에서 표현식은 출력 연산자를 (즉 <mark><<</mark>를) 사용해 메시지를 표준 출력으로 출력한다.
  <pre><code>std::cout << "Enter two numbers: " << std::endl;</code></pre>
  << 연산자는 두 개의 피연산자를 취한다.
  좌측 피연산자는 <mark>ostream</mark> 객체여야만 한다.
  우측 피연산자는 출력할 값이다. 
  연산자는 주어진 <mark>ostream</mark>에 주어진 값을 기재한다.
  출력 연산자의 결과물은 자신의 좌측 피연산자다.
  즉, 우리가 기재한 주어진 값에 대한 <mark>ostream</mark>이 결과물이라는 것이다.
  <p>
  우리의 출력문에는 <mark><<</mark> 연산자가 두 번 쓰였다.
  이는 연산자가 좌측 피연산자를 반환할 때, 첫 번째 연산자의 결과가 두 번째 연산자의 좌측 피연산자가 되기 때문이다.
  결과적으로, 우리는 출력 요청을 연결 지을 수 있다. 
  따라서, 우리의 표현식은 아래 라인과 동치다.
  </p>
  <pre><code>(std::cout << "Enter two numbers:") << std::endl;</code></pre>
  여기서 각 연산자는 같은 객체를 좌측 피연산자로 갖고 있으며, 그것이 이 경우에는 <mark>std::cout</mark>이다.
  대안적으로, 같은 출력물을 문장 두 개로 조성할 수 있다.
  <pre><code>std::cout << "Enter two numbers: ";
std::cout << std::endl;</code></pre>
여기서 첫 번째 출력 연산자가 사용자에게 메시지를 출력한다.
그 메시지는 <b>스트링 리터럴(string literal)</b>인데, 이는 큰따옴표로 묶인 일련의 문자다.
큰따옴표 사이의 텍스트는 표준 출력으로 출력된다.
<p>
두 번째 연산자는 <mark>endl</mark>을 출력하는데, 이는 <b>조작자(manipulator)</b>라고 불리는 특별한 값이다.
<mark>endl</mark>이라고 씀으로써 현재 라인을 끝내고 그 장치에 결부된 <b>버퍼(buffer)</b>를 비우는 효과를 갖는다.
버퍼를 비우는 일은 지금껏 프로그램이 만들어낸 모든 출력물이 메모리에서 쓰이기를 기다리는 것이 아니라 실제로 출력 스트림에 쓰였다는 점을 보장한다.
</p>
<hr width="100%" noshade>
<h4>경고</h4>
<p>프로그래머들은 종종 디버깅 과정에서 문장을 출력한다.
이와 같은 문장은 <b>언제나</b> 스트림을 비워야 한다.
그러지 않는다면, 프로그램이 깨졌을 때, 출력물이 버퍼에 남아, 어디서 프로그램이 깨진 건지에 관한 잘못된 추론이 이어질 수 있기 때문이다.</p>
<hr width="100%" noshade>
<h4>스트림에서 읽기</h4>
사용자에게 입력을 요청했으니, 이제는 그 입력을 읽어야겠다.
우선 <mark>v1</mark>과 <mark>v2</mark>라는 이름의 두 <b>변수(variables)</b>를 정의하여 입력을 붙잡자.
<pre><code>int v1 = 0, v2 = 0;</code></pre>
변수들을 <mark>int</mark> 타입으로 정의했는데, 이는 정수를 표현하는 내장형 타입이다.
우리는 또한 이들을 0으로 <b>초기화(initialize)</b>할 것이다.
변수를 초기화할 때, 우리는 변수가 만들어지는 것과 동시에 변수에 의도하는 값을 부여한다.
<p>
다음 문장은 입력을 읽는다.
</p>
<pre><code>std::cin >> v1 >> v2;</code></pre>
입력 연산자는 (즉 <mark>>></mark>는) 출력 연산자와 비슷하게 행동한다. 
<mark>isstream</mark>을 좌측 피연산자로 취하며, 객체를 우측 피연산자로 취한다.
또, 주어진 <mark>isstream</mark>에서 자료를 취한 다음 주어진 객체에 읽힌 것을 저장한다.
출력 연산자와 마찬가지로, 입력 연산자 또한 자신의 좌측 피연산자를 결과물로 변환한다.
따라서 이 표현식은 아래와 동치다.
<pre><code>(std::cin >> v1) >> v2;</code></pre>
연산자가 자신의 좌측 피연산자를 반환하기에, 우리는 일련의 입력 요청을 하나의 문장으로 묶을 수 있다.
우리의 입력 동작은 <mark>std::cin</mark>에서 두 가지 값을 읽어, 첫 번째 값을 <mark>v1</mark>에 저장하고 두 번째 값을 <mark>v2</mark>에 저장한다.
달리 말해, 우리의 입력 연산자는 다음처럼 실행된다.
<pre><code>std::cin >> v1;
std::cin >> v2;</code></pre>
<h4>프로그램 완성하기</h4>
결과물 출력이 남았다.
<pre><code>std::cout << "The sum of" << v1 << " and " << v2
      << " is " << v1 + v2 << std::endll</code></pre>
이 문장은 일벽 요청보다 길지만, 개념적으로는 유사하다.
각 피연산자가 표준 출력으로 출력된다.
이 예제에서 흥미로운 점은 바로 피연산자가 다른 종류의 값을 갖는다는 것이다.
어떤 피연산자는 스트링 리터럴로, <mark>"The sum of "</mark>를 예로 들 수 있다.
다른 종류로는 <mark>int</mark> 값이 있으며, <mark>v1</mark>, <mark>v2</mark>, 그리고 연산 표현식 <mark>v1 + v2</mark>의 검사 결과가 그 예다.
라이브러리는 다양한 판본의 출력과 입력 연산자를 정의하여 이들처럼 다양한 유형의 피연산자를 다룰 수 있도록 만든다.
<hr width="100%" noshade>
<h4>연습문제 1.2</h4>
<b>연습문제 1.3</b> <mark>Hello, World</mark>를 표준 출력으로 출력하는 프로그램을 작성할 것.
<p>
<b>연습문제 1.4</b> 우리의 프로그램은 덧셈 연산자를 사용했는데, 곱셈 연산자를 사용해 곱셈을 출력할 것.
</p>
<p>
<b>연습문제 1.5</b> 우리는 출력물을 하나의 거대한 문장에 작성했는데, 피연산자 하나씩 문장을 나눠볼 것. 
</p>
<p>
  <b>연습문제 1.6</b>
<pre><code>std::cout << "The sum of " << v1;
      << " and " << v2;
      << " is " << v1 + v2 << std::endl;</code></pre>
이 프로그램이 타당하다면, 무엇을 수행하는가? 
프로그램이 부당하다면, 왜 그런가?
어떻게 고칠 것인가?
</p>

<hr width="100%" noshade>
    <p style="text-align:right;">
      <a href="http://www.charleshouserjr.com/Cplus2.pdf">C++ Primer 5th Edition</a>
      (Lippman, Lajoie, Moo)
      <br>번역 <a href="https://sunbeamktw.github.io/BirCon/">김태원</a></p>
  </body>
</html>
