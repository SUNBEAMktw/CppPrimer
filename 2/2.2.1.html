<!doctype html>
<html>
  
  <head>
    <title>
      CppPrimer
    </title>
    <link rel="icon" href="../favicon.ico">
    <meta charset="utf-8">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet"
      href="//unpkg.com/@highlightjs/cdn-assets@11.2.0/styles/qtcreator-dark.min.css">
<script src="//unpkg.com/@highlightjs/cdn-assets@11.2.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  
  <body>
    <center>
    <a href="../index.html"><h3>C++ 기초</h3></a>      
    <hr width="50%" noshade>
    </center>
    
    <div class="row">
      <div class="left">
        <ol>
          <li><a href="../1/0.html">시작</a></li>
        <li><mark id="red">기본</mark></li>
        <li><a href="../3/0.html">문자열, 벡터, 배열</a></li>
        <li><a href="../4/0.html">표현식</a></li>
        <li><a href="../5/0.html">문장</a></li>
        <li><a href="../6/0.html">함수</a></li>
        <li><a href="../7/0.html">클래스</a></li>
        <li><a href="../8/0.html">IO 라이브러리</a></li>
        <li><a href="../9/0.html">순차 컨테이너</a></li>
        <li><a href="../10/0.html">제네릭 알고리즘</a></li>
        <li><a href="../11/0.html">연관 컨테이너</a></li>
        <li><a href="../12/0.html">동적 메모리</a></li>
        <li><a href="../13/0.html">복사 제어</a></li>
        <li><a href="../14/0.html">연산자 오버로드 및 변환</a></li>
        <li><a href="../15/0.html">객체 지향 프로그래밍</a></li>
        <li><a href="../16/0.html">템플릿과 제네릭 프로그래밍</a></li>
        <li><a href="../17/0.html">라이브러리 특수 기능</a></li>
        <li><a href="../18/0.html">대형 프로그램 도구</a></li>
        <li><a href="../19/0.html">특수 도구 및 기법</a></li>
      </ol> 
      <ul>
        <li>부록 <a href="../A/html">라이브러리</a></li>
      </ul>
      </div>
      
      <div class="center">
        <ol>
          <li><a href="2.1.html">원시 내장형 타입</a></li>
          <li><mark id="red">변수</mark></li>
          <li><a href="2.3.html">복합 타입</a></li>
          <li><a href="2.4.html">const 형식 한정자</a></li>
          <li><a href="2.5.html">타입 다루기</a></li>
          <li><a href="2.6.html">우리만의 자료구조 정의</a></li>
        </ol>
        <ul>
          <li><a href="2.a.html">단원 요약</a></li>
          <li><a href="2.b.html">용어 정리</a></li>
        </ul>
      </div>
      
      <div class="right">
        <ol>
          <li><mark id="red">변수 정의</mark></li>
          <li><a href="2.2.2.html">변수 선언과 정의</a></li>
          <li><a href="2.2.3.html">식별자</a></li>
          <li><a href="2.2.4.html">이름의 범위</a></li>
        </ol>
      </div>
    </div>
    
    <hr width="100%" noshade>
    <p>단순한 변수 정의는 <b>타입 지정자(type specifier)</b>와 쉼표로 구분된 하나 이상의 변수 이름로 구성되며, 세미콜론으로 끝난다. 리스트상의 각 이름은 타입 지정자에 의해 정의된 타입을 가진다. 정의는 (선택적으로) 자신이 정의하는 이름의 하나 이상의 초기 값을 제공한다.</p>

<pre><code>int sum = 0, value // sum, value, and units_sold have type int
	units_sold = 0;	// sum and units_sold have initial value 0
Sales_item item;	// item has type Sales_item (see §1.5.1)
// string is a library type, representing a variable-length sequence of characters
std::string book(“0-201-78345-x”);	// book initialized fromn string literal</code></pre>

<p><mark>book</mark> 정의는 <mark>std::string</mark> 라이브러리를 사용한다. <mark>iostream</mark>과 마찬가지로 <mark>string</mark>은 이름공간 <mark>std</mark>에 정의되어 있다. 3장에서 <mark>string</mark> 타입을 더 자세히 살필 것이다. 지금으로서는 <mark>string</mark>이 변수 길이의 일련의 문자를 표현하는 타입이라는 것이라고 알아두는 것이 유용하다. <mark>string</mark> 라이브러리는 <mark>string</mark> 객체를 초기화할 수 있는 다양한 방법을 제공한다. 이들 방법 가운데 하나는 스트링 리터럴의 복사본으로<a href="2.1.3.html">(§ 2.1.3)</a> 초기화하는 것이다. 따라서 <mark>book</mark>은 <mark>0-201-78345-X</mark>라는 문자를 취하기 위해 초기화된다.</p>

<hr width="100%" noshade>
<h3>용어법: 객체란 무엇인가?</h3>
<p>C++ 프로그래머는 <b>객체(object)</b>라는 용어 사용에 있어 무신경한 것으로 보인다. 일반적으로 말하면 객체란 데이터를 포함할 수 있는 메모리의 한 구역이며 타입을 갖는 것이다.</p>

<p><b>객체</b>라는 용어를 오직 클래스 타입의 변수나 값을 가리키기 위해 사용하기도 한다. 또 명명된 객체와 명명되지 않은 객체를 구분하여, 명명된 객체를 가리키기 위해 <b>변수(variable)</b>라고 하기도 한다. 또 객체와 값을 구분하여 프로그램에 의해 변할 수 있는 데이터를 <b>객체</b>라고 부르고 읽을 수만 있는 데이터를 <b>값</b>이라고 부르기도 한다.</p>

<p>이 책에서는 더 일반적인 용법을 취해 객체를 메모리의 한 구역으로 타입을 갖는 것으로 가리키겠다. 내장형이든 클래스 타입이든, 명명되었든 명명되지 않았든, 읽을 수 있는 것이든 쓰이는 것이든 <b>객체</b>라는 용어를 자유롭게 사용할 것이다.</p>
<hr width="100%" noshade>

<h3>초기화자</h3>
<p><b>초기화된(initialzied)</b> 객체는 만들어지는 그 순간에 특정 값을 가진다. 변수를 초기화하기 위해 쓰이는 값은 복잡한 표현식일 수도 있다. 정의가 둘 이상의 변수를 정의할 때, 각 객체의 이름은 즉각적으로 가시화된다. 따라서 같은 집합상에서 일찍이 정의된 변수의 값으로 다른 변수를 초기화할 수도 있다.</p>

<pre><code>// ok: price is defined and initialized before it is used to initialize discount
double price = 109.99, discount = price * 0.16;
// ok: call applyDiscount and use the return value to initialize salePrice
double salePrice = applyDiscount(price, discount);</code></pre>

<p>C++에서 초기화란 놀라울 정도로 복잡한 주제이기에 계속 돌아볼 것이다. 대다수 프로그래머는 변수를 초기화할 때 쓰이는 <mark>=</mark> 기호에 혼란을 겪는다. 초기화를 일종의 대입으로 생각하는 것이 마음이 편하겠지만, 초기화와 대입은 C++에서 다른 연산이다. 이 개념은 특히 혼란스러운데 왜냐하면 여타 대다수 언어에서는 이런 구분이 무관하며 무시될 수 있기 때문이다. 더군다나 C++에서조차 이런 구분은 종종 상관이 없기 때문이다. 그런데도 이는 핵심적인 개념이기에 텍스트 전반에 걸쳐 반복될 것이다.</p>

<hr width="100%" noshade>
<h3>경고</h3>
<p>초기화는 대입이 아니다. 초기화는 변수 생성 시에 값이 주어질 때 일어난다. 대입은 객체의 현재 값을 없애고 이를 새 값으로 대체한다.</p>
<hr width="100%" noshade>

<h3>리스트 초기화</h3>
<p>초기화가 복잡한 주제인 이유 가운데 하나로 언어가 다양한 방식의 초기화를 정의하는 것을 꼽을 수 있다. 가령 <mark>units_sold</mark>라는 이름의 <mark>int</mark> 변수를 정의하는 다양한 방법이 있다.</p>
<pre><code>int units_sold = 0;
int units_sold = {0};
int units_sold{0};
int units_sold(0);</code></pre>

<p>초기화에서 중괄호의 일반화된 사용은 새로운 표준의 일부분으로 소개되었다. 이 형식의 초기화는 예전에도 허용된 적 있지만 더 제한적이었다. <a href="../3/3.3.1.html">§3.3.1</a>에서 배울 이유에 따라 이와 같은 초기화 형식은 <b>리스트 초기화(list initialization)</b>이라고 불린다. 괄호로 묶인 초기화자의 목록은 이제 객체를 초기화하고 어떤 경우에는 한 객체에 새 값을 대입할 때면 언제든 사용할 수 있다.</p>

<p>내장형 타입의 변수로 쓰일 때면 이 초기화 형식은 중요한 속성을 가진다. 컴파일러는 초기화자가 정보 소실을 유도할 것 같으면 내장형 타입 변수를 리스트 초기화할 수 없도록 제한할 것이다.</p>

<pre><code>long double ld = 3.1415926536;
int a{ld}, b = {ld};	// error: narrowing conversion required
int c(ld), d = ld;	// ok: but value will be truncated</code></pre>

<p>컴파일러는 <mark>a</mark>와 <mark>b</mark>의 초기화를 거부하는데 왜냐하면 <mark>int</mark>를 초기화하기 위해 <mark>long double</mark>을 사용하면 데이터를 잃을 수 있기 때문이다. 적어도 <mark>ld</mark>의 소수부는 절삭될 것이다. 게다가 <mark>ld<mark>의 정수부도 <mark>int</mark>에게는 너무 클 수 있다.</p>

<p>여기 제시된 것처럼 사소한 차이로 보일 수 있겠다. 결국 아무도 <mark>long double</mark>에서 <mark>int</mark>로 직접 초기화하려고 하지는 않을 것 같기 떄문이다. 하지만 16장에서 살필 것인데 그런 초기화가 비의도적으로 일어나기도 한다. 이런 형식의 초기화에 관해서는 <a href="../3/3.2.1.html">§3.2.1</a>과 <a href="../3/3.3.1.html">§3.3.1</a>에서 더 자세히 살필 것이다.</p>

<h3>디폴트 초기화</h3>
<p>변수를 초기화자 없이 정의하면 변수는 <b>디폴트 초기화(default initialized)</b>된다. 이와 같은 변수에게는 “디폴트” 값이 주어진다. 디폴트 값이 무엇인지는 변수의 타입에 의존하며 변수가 정의된 곳에 의존하기도 한다.</p>

<p>명시적으로 초기화되지 않은 내장형 타입 객체의 값은 정의된 장소에 의존한다. 함수 몸체 바깥에서 정의된 변수는 0으로 초기화된다. <a href="../6/6.1.1.html">§6.1.1</a>에서 살필 한 가지 예외가 있는데, 변수 안에서 정의된 내장형 타입 변수는 <b>초기화되지 않았다는 것</b>이다. 초기화되지 않은 내장형 타입 변수의 값은 정의되지 (<a href="2.1.1.html">§2.1.2</a>) 않았다. 값이 정의되지 않은 변수의 값을 복사하거나 접근하고자 하는 것은 오류다.</p>

<p>각 클래스는 그 클래스 타입의 객체를 어떻게 초기화할 수 있는지 제어한다. 말하자면 초기화자 없이 그 타입의 객체를 정의할 수 있는지는 클래스에 달린 문제다. 할 수 있다면 클래스는객체가 결과적으로 가질 값을 결정할 수 있다.</p>

<p>대다수 클래스는 명시적인 초기화자 없이 객체를 정의할 수 있도록 한다. 이런 클래스는 적절한 디폴트 값을 제공한다. 가령 앞서 본 것처럼 <mark>string</mark> 라이브러리 클래스는 초기화자 제공이 없으면 <mark>string</mark>이 결과적으로 빈 문자열이라고 말한다.</p>

<pre><code>std::string empty;	// empty implicitly initialized to the empty string
Sales_item itme;	// default-initialized Sale_item ojbect</code></pre>

어떤 클래스는 모든 객체가 명시적으로 초기화될 것을 요구한다. 컴파일러는 그런 클래스의 객체를 초기화자 없이 생성할 경우 불평할 것이다.

<hr width="100%" noshade>
<h3>메모</h3>
함수 몸체 내부에 정의된 초기화되지 않은 내장형 객체는 정의되지 않은 값을 가진다. 명시적으로 초기화하지 않은 클래스 타입의 객체는 클래스에 의해 정의되는 값을 가진다.
<hr width="100%" noshade>

<h3>연습문제 2.2.1</h3>
<p><b>연습문제 2.9</b> 아래 정의를 설명할 것. 틀린 것을 지적하고 고칠 것.</p>
<ol>
<li><pre><code>std::cin >> int input_value;</code></pre></li>
<li><pre><code>std::cin = {3.14};</code></pre></li>
<li><pre><code>double salary = wage = 9999.99;</code></pre></li>
<li><pre><code>int i = 3.14;</code></pre></li>
</ol>
<p><b>연습문제 2.10</b> 아래 변수들 가운데 초기 값이 있다면 초기 값은 무엇인가?</p>
<pre><code>std::string global_str;
int global_int;
int main()
{
	int local_int;
	std::string local_str;
}</code></pre>

    <hr width="100%" noshade>
    <p style="text-align:right;">
      <a href="http://www.charleshouserjr.com/Cplus2.pdf">C++ Primer 5th Edition</a>
      (Lippman, Lajoie, Moo)
      <br>번역 <a href="https://sunbeamktw.github.io/BirCon/">김태원</a></p>
  </body>
</html>
