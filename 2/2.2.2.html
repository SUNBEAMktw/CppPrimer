<!doctype html>
<html>
  
  <head>
    <title>
      CppPrimer
    </title>
    <link rel="icon" href="../favicon.ico">
    <meta charset="utf-8">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet"
      href="//unpkg.com/@highlightjs/cdn-assets@11.2.0/styles/qtcreator-dark.min.css">
<script src="//unpkg.com/@highlightjs/cdn-assets@11.2.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  
  <body>
    <center>
    <a href="../index.html"><h3>C++ 기초</h3></a>      
    <hr width="50%" noshade>
    </center>
    
    <div class="row">
      <div class="left">
        <ol>
          <li><a href="../1/0.html">시작</a></li>
        <li><mark id="red">기본</mark></li>
        <li><a href="../3/0.html">문자열, 벡터, 배열</a></li>
        <li><a href="../4/0.html">표현식</a></li>
        <li><a href="../5/0.html">문장</a></li>
        <li><a href="../6/0.html">함수</a></li>
        <li><a href="../7/0.html">클래스</a></li>
        <li><a href="../8/0.html">IO 라이브러리</a></li>
        <li><a href="../9/0.html">순차 컨테이너</a></li>
        <li><a href="../10/0.html">제네릭 알고리즘</a></li>
        <li><a href="../11/0.html">연관 컨테이너</a></li>
        <li><a href="../12/0.html">동적 메모리</a></li>
        <li><a href="../13/0.html">복사 제어</a></li>
        <li><a href="../14/0.html">연산자 오버로드 및 변환</a></li>
        <li><a href="../15/0.html">객체 지향 프로그래밍</a></li>
        <li><a href="../16/0.html">템플릿과 제네릭 프로그래밍</a></li>
        <li><a href="../17/0.html">라이브러리 특수 기능</a></li>
        <li><a href="../18/0.html">대형 프로그램 도구</a></li>
        <li><a href="../19/0.html">특수 도구 및 기법</a></li>
      </ol> 
      <ul>
        <li>부록 <a href="../A/html">라이브러리</a></li>
      </ul>
      </div>
      
      <div class="center">
        <ol>
          <li><a href="2.1.html">원시 내장형 타입</a></li>
          <li><mark id="red">변수</mark></li>
          <li><a href="2.3.html">복합 타입</a></li>
          <li><a href="2.4.html">const 형식 한정자</a></li>
          <li><a href="2.5.html">타입 다루기</a></li>
          <li><a href="2.6.html">우리만의 자료구조 정의</a></li>
        </ol>
        <ul>
          <li><a href="2.a.html">단원 요약</a></li>
          <li><a href="2.b.html">용어 정리</a></li>
        </ul>
      </div>
      
      <div class="right">
        <ol>
          <li><a href="2.2.1.html">변수 정의</a></li>
          <li><mark id="red">변수 선언과 정의</mark></li>
          <li><a href="2.2.3.html">식별자</a></li>
          <li><a href="2.2.4.html">이름의 범위</a></li>
        </ol>
      </div>
    </div>
    
    <hr width="100%" noshade>
<p>프로그램이 논리적인 조각들로 작성되기 위해 C++는 <b>분할 컴파일(separate compilation)</b>이라고 알려진 것을 지원한다. 분할 컴파일은 프로그램을 여러 파일로 나누고 각각의 파일이 독립적으로 컴파일되도록 한다.</p>

<p>프로그램을 여러 파일로 나눌 때는 파일들 사이에서 코드를 공유하는 법이 필요하다. 가령 하나의 파일에서 정의된 코드는 또 다른 파일에서 정의된 변수를 사용해야 할 것이다. 구체적인 예를 들면 <mark>std::cout</mark>과 <mark>std::cin</mark>을 생각해볼 수 있다. 이들은 표준 라이브러리 어딘가에 정의된 객체이지만 우리의 프로그램에서도 사용할 수 있다.</p>

<hr width="100%" noshade>
<h3>주의: 초기화되지 않은 변수는 실행시간 문제를 일으킬 수 있다</h3>
<p>초기화되지 않은 변수는 비결정적인 값을 가진다. 초기화되지 않은 변수의 값을 사용하려는 것은 보통 디버그하기 어려운 버그다. 더군다나 컴파일러는 초기화되지 않은 변수 사용을 경고할 수도 있지만 결국에는 이와 같은 에러를 포착하기 어렵다.<p>

<p>초기화되지 않은 변수를 사용했을 때 일어나는 일은 정의되지 않았다. 운이 좋으면 그 객체에 접근한 순간 프로그램이 깨질 수도 있다. 깨진 곳을 찾으면 제대로 초기화되지 않은 변수를 찾기 쉽다. 다른 경우에는 프로그램이 수행되지만 이상한 결과를 내놓기도 한다. 최악은 따로 있다. 한 번은 제대로 실행되는데 이후에는 실패하는 것이다. 더불어 무관한 장소에 코드를 계속 쌓는 일은 우리가 옳다고 생각했던 프로그램이 정확하지 않은 결과를 생산하도록 유도할 수도 있다.</p>

<h4>팁</h4>
<p>모든 내장형 타입 객체를 초기화할 것을 권장한다. 항상 필수적인 것은 아니지만 초기화자를 생략하는 것이 안전할 때를 확신하기 전까지는 초기화자를 제공하는 것이 더 쉽고 안전한 방법이다.</p>
<hr width="100%" noshade>

<p>분할 컴파일을 지원하기 위해 C++는 선언과 정의를 구분한다. <b>선언(declaration)</b>은 프로그램으로 하여금 이름이 알려지도록 만든다. 다른 곳에 정의된 이름을 사용하고자 하는 파일은 그 이름에 대한 선언을 포함한다. <b>정의(definition)</b>는 연관 개체를 생성해낸다.</p>

<p>변수 선언은 변수의 이름과 타입을 특정한다. 변수 정의는 선언의 일환이다. 이름 및 타입 특정에 덧붙여 정의는 저장소를 배정하고 변수에게 초기 값을 제공할 수도 있다.</p>

<p>정의가 아닌 선언을 얻으려면 <mark>extern</mark> 키워드를 붙이고 명시적인 초기화자를 제공하지 않으면 된다.</p>

<pre><code>extern int i;	// declares but does not define i
int j;	// declared and defines j</code></pre>

<p>명시적인 초기화자를 포함하는 선언은 모두 하나의 정의다. <mark>extern</mark>으로 정의된 변수에 초기화자를 제공할 수도 있지만, 이 경우는 <mark>extern</mark>을 덮어 쓰는 꼴이 된다. <mark>extern</mark>을 갖는 초기화자는 하나의 정의다.</p>

<pre><code>extern double pi = 3.1416;	// definition</code></pre>

함수 내부에서 <mark>extern</mark>에 대해 초기화자를 제공하는 것은 오류다.

<hr width="100%" noshade>
<h3>메모</h3>
변수는 단 한 번 정의되어야 하지만 여러 번 선언될 수 있다.
<hr width="100%" noshade>

<p>여기서는 선언과 정의 간의 구분이 이상하게 느껴질 수 있지만 정말 중요한 것이다. 하나 이상의 파일 속의 변수를 사용하려면 그 변수의 정의와 독립적으로 선언을 사용해야 한다. 여러 파일에서 같은 변수를 사용하려면 그 변수를 단 하나의 파일에 정의해야 한다. 그 변수를 사용하는 파일은 그 변수를 선언하되 정의하지 말아야 한다.</p>

<p>C++가 분할 컴파일을 지원하는 방법에 관해서는 <a href="2.6.3.html">§2.6.3</a>과 <a href="6.1.3.html">§6.1.3</a>에서 다룰 것이다.</p>

<hr width="100%" noshade>
<h3>연습문제 2.2.2</h3>
    <p><b>연습문제 2.11</b> 선언인지 정의인지 설명할 것.</p>
<ol>
<li><pre><code>extern int ix = 1024;</code></pre></li>
<li><pre><code>int iy;</code></pre></li>
<li><pre><code>extern int iz;</code></pre></li>
</ol>
<hr width="100%" noshade>
<hr width="100%" noshade>
<h3>핵심 개념: 정적 타이핑</h3>
<p>C++는 <b>정적 타이핑(statically typed)</b> 언어로, 타입이 컴파일 시간에 검사된다는 뜻이다. 타입이 검사되는 과정은 <b>타입 체킹(type checking)</b>이라고 부른다.</p>

<p>앞서 본 것처럼 한 객체의 타입은 그 객체가 수행할 수 있는 연산을 제한한다. C++에서 컴파일러는 우리가 작성한 연산이 타입에 의해 지원되는 것인지 검사한다. 타입이 지원하지 않는 일을 하고자 한다면, 컴파일러는 오류 메시지를 생성하고 실행 파일을 만들지 않는다.</p>

<p>프로그램이 더 복잡해지면서 우리는 정적 타입 체킹이 버그를 찾는 데 도움을 줄 수 있다는 것을 보게 될 것이다. 하지만 정적 체킹의 결과는 우리가 사용하는 모든 개체의 타입이 반드시 컴파일러에게 알려져야 한다는 것이다. 일례로 우리는 변수를 사용할 수 있기 전에 변수의 타입을 선언해야 한다.</p>
<hr width="100%" noshade>

    <hr width="100%" noshade>
    <p style="text-align:right;">
      <a href="http://www.charleshouserjr.com/Cplus2.pdf">C++ Primer 5th Edition</a>
      (Lippman, Lajoie, Moo)
      <br>번역 <a href="https://sunbeamktw.github.io/BirCon/">김태원</a></p>
  </body>
</html>
