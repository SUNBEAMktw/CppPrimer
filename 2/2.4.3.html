<!doctype html>
<html>
  
  <head>
    <title>
      CppPrimer
    </title>
    <link rel="icon" href="../favicon.ico">
    <meta charset="utf-8">
    <link rel="stylesheet" href="../style.css">
    <link rel="stylesheet"
      href="//unpkg.com/@highlightjs/cdn-assets@11.2.0/styles/qtcreator-dark.min.css">
<script src="//unpkg.com/@highlightjs/cdn-assets@11.2.0/highlight.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  
  <body>
    <center>
    <a href="../index.html"><h3>C++ 기초</h3></a>      
    <hr width="50%" noshade>
    </center>
    
    <div class="row">
      <div class="left">
        <ol>
          <li><a href="../1/0.html">시작</a></li>
        <li><mark id="red">기본</mark></li>
        <li><a href="../3/0.html">문자열, 벡터, 배열</a></li>
        <li><a href="../4/0.html">표현식</a></li>
        <li><a href="../5/0.html">문장</a></li>
        <li><a href="../6/0.html">함수</a></li>
        <li><a href="../7/0.html">클래스</a></li>
        <li><a href="../8/0.html">IO 라이브러리</a></li>
        <li><a href="../9/0.html">순차 컨테이너</a></li>
        <li><a href="../10/0.html">제네릭 알고리즘</a></li>
        <li><a href="../11/0.html">연관 컨테이너</a></li>
        <li><a href="../12/0.html">동적 메모리</a></li>
        <li><a href="../13/0.html">복사 제어</a></li>
        <li><a href="../14/0.html">연산자 오버로드 및 변환</a></li>
        <li><a href="../15/0.html">객체 지향 프로그래밍</a></li>
        <li><a href="../16/0.html">템플릿과 제네릭 프로그래밍</a></li>
        <li><a href="../17/0.html">라이브러리 특수 기능</a></li>
        <li><a href="../18/0.html">대형 프로그램 도구</a></li>
        <li><a href="../19/0.html">특수 도구 및 기법</a></li>
      </ol> 
      <ul>
        <li>부록 <a href="../A/html">라이브러리</a></li>
      </ul>
      </div>
      
      <div class="center">
        <ol>
          <li><a href="2.1.html">원시 내장형 타입</a></li>
          <li><a href="2.2.html">변수</a></li>
          <li><a href="2.3.html">복합 타입</a></li>
          <li><mark id="red">const 형식 한정자</mark></li>
          <li><a href="2.5.html">타입 다루기</a></li>
          <li><a href="2.6.html">우리만의 자료구조 정의</a></li>
        </ol>
        <ul>
          <li><a href="2.a.html">단원 요약</a></li>
          <li><a href="2.b.html">용어 정리</a></li>
        </ul>
      </div>
      
      <div class="right">
        <ol>
          <li><a href="2.4.1.html">const에 대한 레퍼런스</a></li>
          <li><a href="2.4.2.html">포인터와 const</a></li>
          <li><mark id="red">최상위 const</mark></li>
          <li><a href="2.4.4.html">constexpr와 상수 표현식</a></li>
        </ol>
      </div>
    </div>
    
    <hr width="100%" noshade>
지금껏 살폈듯이 포인터는 다른 객체를 가리킬 수 있는 객체다. 그 결과로, 우리는 포인터가 <mark>const</mark>인 경우와 포인터가 가리키는 객체가 <mark>const</mark>인 경우를 구분할 수 있다. 우리는 포인터 자체가 <mark>const</mark>인 경우를 일컬어 <b>최상위 const(top-level const)</b>라는 용어를 사용한다. 포인터가 가리키는 객체가 <mark>const</mark>인 경우에는 <mark>최하위 const(low-level const)</mark>라는 용어를 사용한다.

<hr width="100%" noshade>
<h3>연습문제 2.4.2</h3>
<p><b>연습문제 2.27</b> 아래 초기화 가운데 타당한 것은 무엇인가? 그 이유는 무엇인가?</p>
<ol>
<li><pre><code>int i = -1. &r = 0;</code></pre></li>
<li><pre><code>int *const p2 = &i2;</code></pre></li>
<li><pre><code>const int i = -1, &r = 0;</code></pre></li>
<li><pre><code>const int *const p3 = &i2;</code></pre></li>
<li><pre><code>const int *p1 = &i2;</code></pre></li>
<li><pre><code>const int &const r2;</code></pre></li>
<li><pre><code>const int i2 = i, &r = i;</code></pre></li>
</ol>
<p><b>연습문제 2.28</b> 아래 정의를 설명할 것. 타당한 것을 고를 것.</p>
<ol>
<li><pre><code>int i, *const cp;</code></pre></li>
<li><pre><code>int *p1, *const p2;</code></pre></li>
<li><pre><code>const int ic, &r = ic;</code></pre></li>
<li><pre><code>const int *const p3;</code></pre></li>
<li><pre><code>const int *p;</code></pre></li>
</ol>
<p><b>연습문제 2.29</b> 이전 연습문제를 참고하여 아래 대입문 가운데 타당한 것을 고르고 이유를 설명할 것.</p>
<ol>
<li><pre><code>i = ic;</code></pre></li>
<li><pre><code>p1 = p3;</code></pre></li>
<li><pre><code>p1 = &amp;ic;</code></pre></li>
<li><pre><code>p3 = &amp;ic;</code></pre></li>
<li><pre><code>p2 = p1;</code></pre></li>
<li><pre><code>ic = *p3;</code></pre></li>
</ol>
<hr width="100%" noshade>
더 일반적으로 말하면 최상위 <mark>const</mark>는 그 객체 자체가 <mark>const</mark>라는 것을 암시한다. 최상위 <mark>const</mark>는 모든 객체 타입에 나타날 수 있다. 내장형 타입 가운데 하나, 클래스 타입, 포인터 타입을 예로 들 수 있다. 최하위 <mark>const</mark>는 포인터나 레퍼런스와 같은 복합 타입의 기초 타입에서 나타난다. 포인터 타입이 여타 타입과 다르게 최상위와 최하위 <mark>const</mark>를 독립적으로 가질 수 있다는 점에 주목하라.
<pre><code>int i = 0;
int *const p1 = &i;	// we can’t change the value of p1; const is top-level
const int ci = 42;	// we cannot change ci; const is top-level
const int *p2 = &ci;	// we can change p2; const is low-level
const int *const p3 = p2;	// right-most const is top-level, left-most is not
const int &r = ci;	// const in reference types is always low-level</code></pre>
최상위와 최하위 간의 차이는 객체를 복사할 때 가시적이다. 객체를 복사할 때, 최상위 <mark>const</mark>는 무시된다.
<pre><code>i = ci;	// ok: copying the value of ci; top-level const in ci is ignored
p2 = p3;	// okL pointed-to type matches; top level const in p3 is ignored</code></pre>
<p>객체 복사는 객체를 변화시키지 않는다. 이에 따라 복사하거나 복사되는 객체가 <mark>const<mark>인지는 무관하다.</p>

<p>다른 한편 최하위 <mark>const</mark>는 절대 무시되지 않는다. 객체를 복사할 때, 두 객체 모두 같은 최하위 <mark>const</mark>를 갖거나 두 객체 타입 사이에 변환이 이루어져야 한다. 일반적으로, 우리는 <mark>const</mark>가 아닌 타입을 <mark>const</mark>로 변환시킬 수 있지만 반대로는 불가능하다.</p>

<pre><code>int *p = p3;	// error: p3 has a low-level const but p doesn’t
p2 = p3;	// ok: p2 has the same low-level const qualification as p3
p2 = &i;	// ok: we can convert int* to const int*
int &r = ci;	// error: can’t bind an ordinary int& to a const int object
const int &r2 = i;	// ok: can bind const int& to plain int</code></pre>

<mark>p3</mark>은 최상위와 최하위 <mark>const</mark>를 동시에 가진다. <mark>p3</mark>를 복사할 때, 우리는 최상위 <mark>const</mark>를 무시할 수 있지만 그것이 <mark>const</mark> 타입을 가리킨다는 사실을 무시할 수는 없다. 따라서 우리는 <mark>p</mark>를 초기화하기 위해 <mark>p3</mark>을 사용할 수 없다. 다른 한편 우리는 <mark>p3</mark>을 <mark>p2</mark>에 대입할 수 있다. 두 포인터 모두 같은 (최하위 <mark>const</mark>) 타입을 가진다. <mark>p3</mark>이 <mark>const</mark> 포인터라는 사실은 (즉 그것이 최상위 <mark>const</mark>라는 사실은) 상관이 없다.
<hr widht="100%" noshade>
<h3>연습문제 2.4.3</h3>
<p><b>연습문제 2.30</b></p> 각 선언마다 객체가 최상위 <mark>const</mark>를 갖는지 최하위 <mark>const</mark>를 갖는지 설명할 것.</p>
<pre><code>const int v2 = 0;		int v1 = v2;
int *p1 = &v1, &r1 = v1;
const int *p2 = &v2, *const p3 = &i, &r2 = v2;</code></pre>
<p><b>연습문제 2.31</b> 위 연습문제의 대입문 가운데 타당한 것을 결정할 것. 아래 코드에서 최상위 및 최하위 <mark>const</mark>가 어떻게 적용되는지 설명할 것.</p>
<pre><code>r1 = v2;
p1 = p2;	p2 = p1;
p1 = p3;	p2 = p3;</code></pre>

    <hr width="100%" noshade>
    <p style="text-align:right;">
      <a href="http://www.charleshouserjr.com/Cplus2.pdf">C++ Primer 5th Edition</a>
      (Lippman, Lajoie, Moo)
      <br>번역 <a href="https://sunbeamktw.github.io/BirCon/">김태원</a></p>
  </body>
</html>
